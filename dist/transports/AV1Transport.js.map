{"version":3,"file":"AV1Transport.js","sourceRoot":"","sources":["../../lib/transports/AV1Transport.ts"],"names":[],"mappings":"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","sourcesContent":["// Handle AV1 Video\r\n// Process SDP and RTP packets\r\n// De-packetize RTP packets to re-create AV1 OBUs\r\n// Write AV1 OBUs to a .obu file which can be played with \"ffplay\"\r\n//\r\n// By Roger Hardiman, May 2025\r\n\r\nimport RTSPClient from \"../RTSPClient\";\r\nimport { RTPPacket } from \"../util\";\r\n\r\nimport * as transform from \"sdp-transform\";\r\nimport { Writable } from \"stream\";\r\n\r\ninterface Details {\r\n  codec: string\r\n  mediaSource: transform.MediaDescription\r\n  rtpChannel: number,\r\n  rtcpChannel: number\r\n}\r\n\r\nexport default class AV1Transport {\r\n  client: RTSPClient;\r\n  stream: Writable;\r\n\r\n  rtpPackets: Buffer[] = [];\r\n  waitingForSequenceHeader = true; // used when writing .obu file as 'ffplay' does not like it if the first OBUs are not TD then SH\r\n\r\n  constructor(client: RTSPClient, stream: Writable, details: Details) {\r\n    this.client = client;\r\n    this.stream = stream;\r\n\r\n    // process 'fmtp'\r\n    this.processConnectionDetails(details);\r\n\r\n    client.on(\"data\", (channel, data, packet) => {\r\n      if (channel == details.rtpChannel) {\r\n        this.processRTPPacket(packet);\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n  processConnectionDetails(details: Details): void {\r\n    // There is no Sequence Header (the extra_data / parameter set) in the SDP of AV1\r\n    // and currently we have no use for profile, level-idx or tier\r\n    const fmtp = (details.mediaSource.fmtp)[0];\r\n\r\n    if (!fmtp) {\r\n      return;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    const fmtpConfig = transform.parseParams(fmtp.config);\r\n\r\n    /*\r\n    const _profile = fmtpConfig['profile'].toString();\r\n    const _level_idx = fmtpConfig['level-idx'].toString();\r\n    const _tier = fmtpConfig['tier'].toString();\r\n    */\r\n  }\r\n\r\n  processRTPPacket(packet: RTPPacket): void {\r\n    // Accumatate RTP packets\r\n    this.rtpPackets.push(packet.payload);\r\n\r\n    // When Marker is set to 1 pass the group of packets to processRTPFrame()\r\n    if (packet.marker == 1) {\r\n      this.processRTPFrame(this.rtpPackets);\r\n      this.rtpPackets = [];\r\n    }\r\n  }\r\n\r\n  processRTPFrame(rtpPackets: Buffer[]): void {\r\n    const obus: Buffer[] = []; // the OBUs from the RTSP server, which normally come without their length bytes (leb128) \r\n    \r\n    for (let i = 0; i < rtpPackets.length; i++) {\r\n\r\n      // The RTP packet can contain more than one OBU element\r\n\r\n      // Examine the first byte of the RTP data, the Aggregation Header.\r\n      // Z = 1 Indicates that the first OBU element in this RTP packet is a contination of the last OBU element from the last packet (ie fragmentation)\r\n      // Y = 1 Indicates that the last OBU element in this RTP packet will be fragmented and will continue in the next RTP packet (so next RTP packet will have Z=1)\r\n      \r\n      // W = Number of OBU elements in this RTP Packet, or 0 if the number of OBUs is not given\r\n      // If W = 0, all OBU elements are prefixed with a LEB128 length.\r\n      // If W > 0, the OBU elements _except the last one_ have a LEB128 length prefix. Last OBU has no LEB128 length prefix. It can be computed from the RTP payload size\r\n\r\n      // N = 1 Indicates first packet of a Coded Video Sequence\r\n\r\n      // 0 1 2 3 4 5 6 7\r\n      // +-+-+-+-+-+-+-+-+\r\n      // |Z|Y| W |N|-|-|-|\r\n      // +-+-+-+-+-+-+-+-+\r\n      const packet = rtpPackets[i];\r\n\r\n      let ptr = 0;\r\n      const aggregation_header = packet[ptr];\r\n      ptr++\r\n      const aggregation_header_z_bit = (aggregation_header >> 7) & 0x01;\r\n      //const aggregation_header_y_bit = (aggregation_header >> 6) & 0x01;\r\n      const aggregation_header_w = (aggregation_header >> 4) & 0x03;\r\n      //const aggregation_header_n_bit = (aggregation_header >> 3) & 0x01;\r\n\r\n      /*\r\n      if (aggregation_header_z_bit == 1) {\r\n        console.log(\"AV1 Z Fragmentation\");\r\n      }\r\n      if (aggregation_header_y_bit == 1) {\r\n        console.log(\"AV1 Y Fragmentation\");\r\n      }\r\n      if (aggregation_header_n_bit == 1) {\r\n        console.log(\"AV1 N Bit is set\");\r\n      }\r\n      */\r\n\r\n      let obuCount = 0;\r\n\r\n        // Loop over each OBU\r\n        while (ptr < packet.length) {\r\n\r\n          obuCount++;\r\n\r\n          // Check if the OBU element will be prefixed with a LEB128 length\r\n          let hasLeb128Prefix = false;\r\n          if (aggregation_header_w == 0) hasLeb128Prefix = true;\r\n          if (aggregation_header_w != 0 && obuCount != aggregation_header_w) hasLeb128Prefix = true;\r\n\r\n          let obu_element_size = 0;\r\n          if (hasLeb128Prefix) {\r\n            for (let i = 0; i < 8; i++) { // max 8 bytes\r\n              const lebByte = packet[ptr];\r\n              ptr++;\r\n\r\n              obu_element_size = obu_element_size + ((lebByte & 0x7F) << (i * 7));\r\n\r\n              if ((lebByte & 0x80) == 0) {\r\n                // finished\r\n                break;\r\n              }\r\n            }\r\n          } else {\r\n            // no LEB128. Size is the remaining bytes\r\n            obu_element_size = packet.length - ptr;\r\n          }\r\n\r\n          // Extract the OBU\r\n          let obu = packet.slice(ptr, ptr + obu_element_size);\r\n          ptr = ptr + obu_element_size;\r\n\r\n          // Check Z bit. If Z = 1 we need to append the new OBU data to the Partial OBU data (fragmented data) from the last RTP packet\r\n          if (aggregation_header_z_bit == 1 && obuCount == 1) {\r\n            // Pop off the last 'partial' OBU\r\n            const lastPartialObu = obus.pop();\r\n            if (lastPartialObu == undefined) {\r\n              // error. We do not have any partial data to append this new OBU data to so drop the new OBU.\r\n            } else {\r\n              const combinedObuData = Buffer.concat([\r\n                lastPartialObu,\r\n                obu\r\n              ]);\r\n              obu = combinedObuData;\r\n            }\r\n          }\r\n\r\n          // We have an OBU so store it\r\n          // Note if 'Y' is set, and we are processing the last OBU in the RTP packet, the data will be only part of the fragmented data\r\n          // but we don't check the Y bit. We rely on the Z bit being set to 1 in the next RTP packet\r\n          if (obu.length > 0) {\r\n            obus.push(obu);\r\n          }\r\n      } // Ptr now parsed all OBU elements in this RTP packet\r\n\r\n\r\n    } // end for-each RTP packet in the Frame\r\n\r\n\r\n    // Write out all the OBUs\r\n    // When we write to a File, we need to add the Temporal Delimiter (TD)\r\n    // and then the SEQUENCE_HEADER (SH)\r\n    // and then the other OBUs.\r\n    // The OBUs are modified to include a LEB128 size as required in the AV1 File Format Spec Section 5 file format\r\n    // The modification is needed as the AV1 RTSP Spec strips out the OBU lengths and replaces them with OBU Prefix lengths\r\n    // which come before the OBU instead of inside the OBU.\r\n    // There is an Annex B format that keeps the length bytes as prefixes on the OBU (instead of inside them) but I've not implemented that\r\n\r\n    // Check if this Frame includes a Sequence Header\r\n    if (this.waitingForSequenceHeader) {\r\n      for (const obu of obus) {\r\n        const obuHeader = obu[0];\r\n        const obu_type = (obuHeader >> 3) & 0x0F;\r\n        if (obu_type == 1) { // Sequence Header\r\n          this.waitingForSequenceHeader = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.waitingForSequenceHeader) {\r\n      // drop this RTP frame\r\n      console.log(\"AV1: Waiting for Sequence Header\")\r\n    }\r\n    else\r\n    {\r\n      // Write the OBUs\r\n      const temporalDelimiter = Buffer.from([0x12, 0x00]);\r\n      this.stream.write(temporalDelimiter);\r\n      \r\n      for (const obu of obus) {\r\n\r\n        // Take a look at the OBU and see what it contains to verify it looks correct\r\n        // OBU Header Byte\r\n        // --------------------------------------------------------------------------------\r\n        // |      7        |  6,5,4,3     |        2         |      1      |      0       |\r\n        // |1 bit forbidden|4 bit OBU Type|1 bit hasExtension|1 bit hasSize|1 bit reserved|\r\n        // --------------------------------------------------------------------------------\r\n        if (obu.length > 0) {\r\n          const obuHeader = obu[0];\r\n          //const forbidden_bit = (obuHeader >> 7) & 0x01;\r\n          const obu_type = (obuHeader >> 3) & 0x0F;\r\n          const extension_bit = (obuHeader >> 2) & 0x01;\r\n          const size_bit = (obuHeader >> 1) & 0x01;\r\n\r\n          /*\r\n          const obu_name = this.GetOBUName(obu_type);\r\n          console.log(\"Found AV1 OBU:\" + obu_name);\r\n\r\n          if (forbidden_bit == 1) {\r\n            console.log(\"OBU Forbidden Bit Error\");\r\n          }\r\n          \r\n          if (obu_name == \"Reserved\") {\r\n            console.log(\"OBU Type Error\");\r\n          }\r\n          */\r\n\r\n          if (this.waitingForSequenceHeader) {\r\n            if (obu_type == 1) {\r\n              this.waitingForSequenceHeader = false;\r\n\r\n              // Write the First TD\r\n\r\n\r\n            } else {\r\n              // we are still waiting so drop this OBU\r\n              console.log(\"AV1 file writing: Dropping OBU while waiting for Sequence Header\")\r\n              continue;\r\n            }\r\n          }\r\n            \r\n\r\n          // In order to write to a .obu file, we have to ensure there is a LEB128 Size after the OBU Header Byte (and Optional Extension Byte)\r\n          // The LEB128 length gets stripped out in RTP packets\r\n          if (size_bit == 0) {\r\n            let size = 0;\r\n            if (extension_bit == 0) size = obu.length - 1; // -1 for the OBU header\r\n            if (extension_bit == 1) size = obu.length - 2; // -2 for the OBU header and the Header Extension Byte\r\n            \r\n            // Convert the Size into a LEB128 byte sequence\r\n            const leb128_bytes = [];\r\n            while (size > 0) {\r\n              const lower_7_bits = (size & 0x7F);\r\n              if (size <= 127) {\r\n                leb128_bytes.push(lower_7_bits); // leave msbit as 0\r\n              } else {\r\n                leb128_bytes.push(0x80 + lower_7_bits); // set msbit to 1\r\n              }\r\n              size = (size >> 7);\r\n            }\r\n            const leb128Buffer = Buffer.from(leb128_bytes);\r\n\r\n            // Insert the leb128 size into the OBU\r\n            const header_and_extention_len = (extension_bit == 0 ? 1 : 2); // length of header PLUS extension\r\n            // Insert the LEB128 length\r\n            const newObu = Buffer.concat([\r\n              obu.slice(0, 0 + header_and_extention_len),\r\n              leb128Buffer,\r\n              obu.slice(header_and_extention_len,obu.length)\r\n            ]);\r\n            // Set the hasSize flag to '1' in the OBU Header\r\n            newObu[0] = newObu[0] | 0x02;\r\n\r\n            // WRITE DATA\r\n            this.stream.write(newObu);\r\n          }\r\n          else\r\n          {\r\n            // This OBU came with a LEB128 length. The AV1 RTSP Spec says the RTSP server should strip them out, but this\r\n            // handles the case where a RTSP Server leaves them in\r\n            // WRITE DATA\r\n            this.stream.write(obu);\r\n          }\r\n        }\r\n      } // for-each OBU in OBUs Arrau\r\n    }\r\n  }\r\n\r\n\r\n  GetOBUName(obu_type: number): string {\r\n    switch (obu_type)\r\n    {\r\n        case 0: return \"Reserved\";\r\n        case 1: return \"SEQUENCE_HEADER\";\r\n        case 2: return \"TEMPORAL_DELIMITER\";\r\n        case 3: return \"FRAME_HEADER\";\r\n        case 4: return \"TILE_GROUP\";\r\n        case 5: return \"METADATA\";\r\n        case 6: return \"FRAME\";\r\n        case 7: return \"REDUNDANT_FRAME_HEADER\";\r\n        case 8: return \"TILE_LIST\";\r\n        case 9: return \"Reserved\";\r\n        case 10: return \"Reserved\";\r\n        case 11: return \"Reserved\";\r\n        case 12: return \"Reserved\";\r\n        case 13: return \"Reserved\";\r\n        case 14: return \"Reserved\";\r\n        case 15: return \"PADDING\";\r\n    }\r\n\r\n    return \"Error getting OBU Type\";\r\n  }\r\n}\r\n"]}