{"version":3,"file":"AV1Transport.js","sourceRoot":"","sources":["../../lib/transports/AV1Transport.ts"],"names":[],"mappings":"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","sourcesContent":["// Handle AV1 Video\n// Process SDP and RTP packets\n// De-packetize RTP packets to re-create AV1 OBUs\n// Write AV1 OBUs to a .obu file which can be played with \"ffplay\"\n//\n// By Roger Hardiman, May 2025\n\nimport RTSPClient from \"../RTSPClient\";\nimport { RTPPacket } from \"../util\";\n\nimport * as transform from \"sdp-transform\";\nimport { Writable } from \"stream\";\n\ninterface Details {\n  codec: string\n  mediaSource: transform.MediaDescription\n  rtpChannel: number,\n  rtcpChannel: number\n}\n\nexport default class AV1Transport {\n  client: RTSPClient;\n  stream: Writable;\n\n  rtpPackets: Buffer[] = [];\n  waitingForSequenceHeader = true; // used when writing .obu file as 'ffplay' does not like it if the first OBUs are not TD then SH\n\n  constructor(client: RTSPClient, stream: Writable, details: Details) {\n    this.client = client;\n    this.stream = stream;\n\n    // process 'fmtp'\n    this.processConnectionDetails(details);\n\n    client.on(\"data\", (channel, data, packet) => {\n      if (channel == details.rtpChannel) {\n        this.processRTPPacket(packet);\n      }\n    });\n\n  }\n\n  processConnectionDetails(details: Details): void {\n    // There is no Sequence Header (the extra_data / parameter set) in the SDP of AV1\n    // and currently we have no use for profile, level-idx or tier\n    const fmtp = (details.mediaSource.fmtp)[0];\n\n    if (!fmtp) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const fmtpConfig = transform.parseParams(fmtp.config);\n\n    /*\n    const _profile = fmtpConfig['profile'].toString();\n    const _level_idx = fmtpConfig['level-idx'].toString();\n    const _tier = fmtpConfig['tier'].toString();\n    */\n  }\n\n  processRTPPacket(packet: RTPPacket): void {\n    // Accumatate RTP packets\n    this.rtpPackets.push(packet.payload);\n\n    // When Marker is set to 1 pass the group of packets to processRTPFrame()\n    if (packet.marker == 1) {\n      this.processRTPFrame(this.rtpPackets);\n      this.rtpPackets = [];\n    }\n  }\n\n  processRTPFrame(rtpPackets: Buffer[]): void {\n    const obus: Buffer[] = []; // the OBUs from the RTSP server, which normally come without their length bytes (leb128) \n    \n    for (let i = 0; i < rtpPackets.length; i++) {\n\n      // The RTP packet can contain more than one OBU element\n\n      // Examine the first byte of the RTP data, the Aggregation Header.\n      // Z = 1 Indicates that the first OBU element in this RTP packet is a contination of the last OBU element from the last packet (ie fragmentation)\n      // Y = 1 Indicates that the last OBU element in this RTP packet will be fragmented and will continue in the next RTP packet (so next RTP packet will have Z=1)\n      \n      // W = Number of OBU elements in this RTP Packet, or 0 if the number of OBUs is not given\n      // If W = 0, all OBU elements are prefixed with a LEB128 length.\n      // If W > 0, the OBU elements _except the last one_ have a LEB128 length prefix. Last OBU has no LEB128 length prefix. It can be computed from the RTP payload size\n\n      // N = 1 Indicates first packet of a Coded Video Sequence\n\n      // 0 1 2 3 4 5 6 7\n      // +-+-+-+-+-+-+-+-+\n      // |Z|Y| W |N|-|-|-|\n      // +-+-+-+-+-+-+-+-+\n      const packet = rtpPackets[i];\n\n      let ptr = 0;\n      const aggregation_header = packet[ptr];\n      ptr++\n      const aggregation_header_z_bit = (aggregation_header >> 7) & 0x01;\n      //const aggregation_header_y_bit = (aggregation_header >> 6) & 0x01;\n      const aggregation_header_w = (aggregation_header >> 4) & 0x03;\n      //const aggregation_header_n_bit = (aggregation_header >> 3) & 0x01;\n\n      /*\n      if (aggregation_header_z_bit == 1) {\n        console.log(\"AV1 Z Fragmentation\");\n      }\n      if (aggregation_header_y_bit == 1) {\n        console.log(\"AV1 Y Fragmentation\");\n      }\n      if (aggregation_header_n_bit == 1) {\n        console.log(\"AV1 N Bit is set\");\n      }\n      */\n\n      let obuCount = 0;\n\n        // Loop over each OBU\n        while (ptr < packet.length) {\n\n          obuCount++;\n\n          // Check if the OBU element will be prefixed with a LEB128 length\n          let hasLeb128Prefix = false;\n          if (aggregation_header_w == 0) hasLeb128Prefix = true;\n          if (aggregation_header_w != 0 && obuCount != aggregation_header_w) hasLeb128Prefix = true;\n\n          let obu_element_size = 0;\n          if (hasLeb128Prefix) {\n            for (let i = 0; i < 8; i++) { // max 8 bytes\n              const lebByte = packet[ptr];\n              ptr++;\n\n              obu_element_size = obu_element_size + ((lebByte & 0x7F) << (i * 7));\n\n              if ((lebByte & 0x80) == 0) {\n                // finished\n                break;\n              }\n            }\n          } else {\n            // no LEB128. Size is the remaining bytes\n            obu_element_size = packet.length - ptr;\n          }\n\n          // Extract the OBU\n          let obu = packet.slice(ptr, ptr + obu_element_size);\n          ptr = ptr + obu_element_size;\n\n          // Check Z bit. If Z = 1 we need to append the new OBU data to the Partial OBU data (fragmented data) from the last RTP packet\n          if (aggregation_header_z_bit == 1 && obuCount == 1) {\n            // Pop off the last 'partial' OBU\n            const lastPartialObu = obus.pop();\n            if (lastPartialObu == undefined) {\n              // error. We do not have any partial data to append this new OBU data to so drop the new OBU.\n            } else {\n              const combinedObuData = Buffer.concat([\n                lastPartialObu,\n                obu\n              ]);\n              obu = combinedObuData;\n            }\n          }\n\n          // We have an OBU so store it\n          // Note if 'Y' is set, and we are processing the last OBU in the RTP packet, the data will be only part of the fragmented data\n          // but we don't check the Y bit. We rely on the Z bit being set to 1 in the next RTP packet\n          if (obu.length > 0) {\n            obus.push(obu);\n          }\n      } // Ptr now parsed all OBU elements in this RTP packet\n\n\n    } // end for-each RTP packet in the Frame\n\n\n    // Write out all the OBUs\n    // When we write to a File, we need to add the Temporal Delimiter (TD)\n    // and then the SEQUENCE_HEADER (SH)\n    // and then the other OBUs.\n    // The OBUs are modified to include a LEB128 size as required in the AV1 File Format Spec Section 5 file format\n    // The modification is needed as the AV1 RTSP Spec strips out the OBU lengths and replaces them with OBU Prefix lengths\n    // which come before the OBU instead of inside the OBU.\n    // There is an Annex B format that keeps the length bytes as prefixes on the OBU (instead of inside them) but I've not implemented that\n\n    // Check if this Frame includes a Sequence Header\n    if (this.waitingForSequenceHeader) {\n      for (const obu of obus) {\n        const obuHeader = obu[0];\n        const obu_type = (obuHeader >> 3) & 0x0F;\n        if (obu_type == 1) { // Sequence Header\n          this.waitingForSequenceHeader = false;\n          break;\n        }\n      }\n    }\n\n    if (this.waitingForSequenceHeader) {\n      // drop this RTP frame\n      console.log(\"AV1: Waiting for Sequence Header\")\n    }\n    else\n    {\n      // Write the OBUs\n      const temporalDelimiter = Buffer.from([0x12, 0x00]);\n      this.stream.write(temporalDelimiter);\n      \n      for (const obu of obus) {\n\n        // Take a look at the OBU and see what it contains to verify it looks correct\n        // OBU Header Byte\n        // --------------------------------------------------------------------------------\n        // |      7        |  6,5,4,3     |        2         |      1      |      0       |\n        // |1 bit forbidden|4 bit OBU Type|1 bit hasExtension|1 bit hasSize|1 bit reserved|\n        // --------------------------------------------------------------------------------\n        if (obu.length > 0) {\n          const obuHeader = obu[0];\n          //const forbidden_bit = (obuHeader >> 7) & 0x01;\n          const obu_type = (obuHeader >> 3) & 0x0F;\n          const extension_bit = (obuHeader >> 2) & 0x01;\n          const size_bit = (obuHeader >> 1) & 0x01;\n\n          /*\n          const obu_name = this.GetOBUName(obu_type);\n          console.log(\"Found AV1 OBU:\" + obu_name);\n\n          if (forbidden_bit == 1) {\n            console.log(\"OBU Forbidden Bit Error\");\n          }\n          \n          if (obu_name == \"Reserved\") {\n            console.log(\"OBU Type Error\");\n          }\n          */\n\n          if (this.waitingForSequenceHeader) {\n            if (obu_type == 1) {\n              this.waitingForSequenceHeader = false;\n\n              // Write the First TD\n\n\n            } else {\n              // we are still waiting so drop this OBU\n              console.log(\"AV1 file writing: Dropping OBU while waiting for Sequence Header\")\n              continue;\n            }\n          }\n            \n\n          // In order to write to a .obu file, we have to ensure there is a LEB128 Size after the OBU Header Byte (and Optional Extension Byte)\n          // The LEB128 length gets stripped out in RTP packets\n          if (size_bit == 0) {\n            let size = 0;\n            if (extension_bit == 0) size = obu.length - 1; // -1 for the OBU header\n            if (extension_bit == 1) size = obu.length - 2; // -2 for the OBU header and the Header Extension Byte\n            \n            // Convert the Size into a LEB128 byte sequence\n            const leb128_bytes = [];\n            while (size > 0) {\n              const lower_7_bits = (size & 0x7F);\n              if (size <= 127) {\n                leb128_bytes.push(lower_7_bits); // leave msbit as 0\n              } else {\n                leb128_bytes.push(0x80 + lower_7_bits); // set msbit to 1\n              }\n              size = (size >> 7);\n            }\n            const leb128Buffer = Buffer.from(leb128_bytes);\n\n            // Insert the leb128 size into the OBU\n            const header_and_extention_len = (extension_bit == 0 ? 1 : 2); // length of header PLUS extension\n            // Insert the LEB128 length\n            const newObu = Buffer.concat([\n              obu.slice(0, 0 + header_and_extention_len),\n              leb128Buffer,\n              obu.slice(header_and_extention_len,obu.length)\n            ]);\n            // Set the hasSize flag to '1' in the OBU Header\n            newObu[0] = newObu[0] | 0x02;\n\n            // WRITE DATA\n            this.stream.write(newObu);\n          }\n          else\n          {\n            // This OBU came with a LEB128 length. The AV1 RTSP Spec says the RTSP server should strip them out, but this\n            // handles the case where a RTSP Server leaves them in\n            // WRITE DATA\n            this.stream.write(obu);\n          }\n        }\n      } // for-each OBU in OBUs Arrau\n    }\n  }\n\n\n  GetOBUName(obu_type: number): string {\n    switch (obu_type)\n    {\n        case 0: return \"Reserved\";\n        case 1: return \"SEQUENCE_HEADER\";\n        case 2: return \"TEMPORAL_DELIMITER\";\n        case 3: return \"FRAME_HEADER\";\n        case 4: return \"TILE_GROUP\";\n        case 5: return \"METADATA\";\n        case 6: return \"FRAME\";\n        case 7: return \"REDUNDANT_FRAME_HEADER\";\n        case 8: return \"TILE_LIST\";\n        case 9: return \"Reserved\";\n        case 10: return \"Reserved\";\n        case 11: return \"Reserved\";\n        case 12: return \"Reserved\";\n        case 13: return \"Reserved\";\n        case 14: return \"Reserved\";\n        case 15: return \"PADDING\";\n    }\n\n    return \"Error getting OBU Type\";\n  }\n}\n"]}