{"version":3,"file":"AACTransport.js","sourceRoot":"","sources":["../../lib/transports/AACTransport.ts"],"names":[],"mappings":"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","sourcesContent":["// De-packetize RTP packets to re-create AAC High Bit Rate (hbr) Audio\r\n// Write Audio to a .aac file\r\n// By Roger Hardiman, October 2019\r\n\r\nimport RTSPClient from \"../RTSPClient\";\r\nimport { RTPPacket, BitStream } from \"../util\";\r\n\r\nimport * as transform from \"sdp-transform\";\r\nimport { Writable } from \"stream\";\r\n\r\ninterface Details {\r\n  codec: string;\r\n  mediaSource: transform.MediaDescription;\r\n  rtpChannel: number;\r\n  rtcpChannel: number;\r\n}\r\n\r\nexport default class AACTransport {\r\n  client: RTSPClient;\r\n  stream: Writable;\r\n\r\n  ObjectType = 0;\r\n  FrequencyIndex = 0;\r\n  ChannelConfiguration = 0;\r\n\r\n  constructor(client: RTSPClient, stream: Writable, details: Details) {\r\n    this.client = client;\r\n    this.stream = stream;\r\n\r\n    client.on(\"data\", (channel, data, packet) => {\r\n      if (channel == details.rtpChannel) {\r\n        this.processRTPPacket(packet);\r\n      }\r\n    });\r\n\r\n    // Process the SDP to get the parameters for the AAC audio\r\n    // \"profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1490\"\r\n    const fmtp = details.mediaSource.fmtp[0];\r\n    const fmtpConfig = transform.parseParams(fmtp.config);\r\n\r\n    const bs = new BitStream();\r\n    bs.AddHexString(fmtpConfig[\"config\"].toString());\r\n\r\n    /***\r\n    5 bits: object type\r\n        if (object type == 31)\r\n        6 bits + 32: object type\r\n    4 bits: frequency index\r\n        if (frequency index == 15)\r\n        24 bits: frequency\r\n    4 bits: channel configuration\r\n    var bits: AOT Specific Config\r\n    ***/\r\n\r\n    // Read 5 bits\r\n    this.ObjectType = bs.Read(5);\r\n\r\n    // Read 4 bits\r\n    this.FrequencyIndex = bs.Read(4);\r\n\r\n    // Read 4 bits\r\n    this.ChannelConfiguration = bs.Read(4);\r\n  }\r\n\r\n  processRTPPacket(packet: RTPPacket): void {\r\n    // RTP Payload for MPEG4-GENERIC consis of multiple blocks of data\r\n\r\n    // Each block has 3 parts\r\n    // Part 1 - Acesss Unit Header Length + Header\r\n    // Part 2 - Access Unit Auxiliary Data Length + Data (not used in AAC High Bitrate)\r\n    // Part 3 - Access Unit Audio Data\r\n\r\n    const rtp_payload = packet.payload;\r\n    let ptr = 0;\r\n    const audio_data = [];\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      if (ptr + 4 > rtp_payload.length) break; // 2 bytes for AU Header Length, 2 bytes of AU Header payload\r\n\r\n      // Get Size of the AU Header\r\n      const au_headers_length_bits =\r\n        (rtp_payload[ptr] << 8) + (rtp_payload[ptr + 1] << 0); // 16 bits\r\n      const au_headers_length = Math.ceil(au_headers_length_bits / 8.0);\r\n      ptr += 2;\r\n\r\n      // Examine the AU Header. Get the size of the AAC data\r\n      const aac_frame_size =\r\n        ((rtp_payload[ptr] << 8) + (rtp_payload[ptr + 1] << 0)) >> 3; // 13 bits\r\n      const _aac_index_delta = rtp_payload[ptr + 1] & 0x03; // 3 bits\r\n      ptr += au_headers_length;\r\n\r\n      // extract the AAC block\r\n      if (ptr + aac_frame_size > rtp_payload.length) break; // not enough data to copy\r\n      audio_data.push(rtp_payload.slice(ptr, ptr + aac_frame_size));\r\n      ptr += aac_frame_size;\r\n    }\r\n\r\n    // Write Audio Data Transport Stream (adts) header\r\n    // followed by the AAC data\r\n    for (let x = 0; x < audio_data.length; x++) {\r\n      const data = audio_data[x];\r\n\r\n      const bs = new BitStream(); //TODO - we could cache the header bitstream\r\n\r\n      bs.AddValue(0xfff, 12); // (a) Start of data\r\n      bs.AddValue(0, 1); // (b) Version ID, 0 = MPEG4\r\n      bs.AddValue(0, 2); // (c) Layer always 2 bits set to 0\r\n      const protection_absent = 1;\r\n      bs.AddValue(protection_absent, 1); // (d) 1 = No CRC\r\n      bs.AddValue(this.ObjectType - 1, 2); // (e) MPEG Object Type / Profile, minus 1\r\n      bs.AddValue(this.FrequencyIndex, 4); // (f)\r\n      bs.AddValue(0, 1); // (g) private bit. Always zero\r\n      bs.AddValue(this.ChannelConfiguration, 3); // (h)\r\n      bs.AddValue(0, 1); // (i) originality\r\n      bs.AddValue(0, 1); // (j) home\r\n      bs.AddValue(0, 1); // (k) copyrighted id\r\n      bs.AddValue(0, 1); // (l) copyright id start\r\n      bs.AddValue(data.length + 7, 13); // (m) AAC data + size of the ASDT header\r\n      bs.AddValue(2047, 11); // (n) buffer fullness ???\r\n      const num_acc_frames = 1;\r\n      bs.AddValue(num_acc_frames - 1, 1); // (o) num of AAC Frames, minus 1\r\n\r\n      // TODO If Protection was On [value=0], there would be a 16 bit CRC here\r\n      // if (protection_absent == 0) bs.AddValue(/*Calc CRC()*/, 16); // (p)\r\n\r\n      const header = bs.ToArray();\r\n\r\n      // write to the aac file\r\n      this.stream.write(header);\r\n      this.stream.write(data);\r\n    }\r\n  }\r\n}\r\n"]}