{"version":3,"file":"H266Transport.js","sourceRoot":"","sources":["../../lib/transports/H266Transport.ts"],"names":[],"mappings":";AAAA,8BAA8B;AAC9B,uDAAuD;AACvD,sCAAsC;;AAQtC,2CAA2C;AAG3C,8BAA8B;AAC9B,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AAS1D,MAAqB,aAAa;IAOhC,YAAY,MAAkB,EAAE,MAAgB,EAAE,OAAgB;QAJlE,aAAQ,GAAG,KAAK,CAAC,CAAC,gFAAgF;QAElG,eAAU,GAAa,EAAE,CAAC;QAGxB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QAErB,gDAAgD;QAChD,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,CAAC;QAEvC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE;YAC1C,IAAI,OAAO,IAAI,OAAO,CAAC,UAAU,EAAE;gBACjC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;aAC/B;QACH,CAAC,CAAC,CAAC;IAEL,CAAC;IAED,wBAAwB,CAAC,OAAgB;;QACvC,0EAA0E;QAC1E,sGAAsG;QACtG,oCAAoC;QACpC,MAAM,IAAI,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAE3C,IAAI,CAAC,IAAI,EAAE;YACT,OAAO;SACR;QAED,MAAM,UAAU,GAAG,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtD,MAAM,GAAG,GAAG,CAAC,WAAW,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAA,UAAU,CAAC,WAAW,CAAC,0CAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC5G,MAAM,GAAG,GAAG,CAAC,WAAW,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAA,UAAU,CAAC,WAAW,CAAC,0CAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC5G,MAAM,GAAG,GAAG,CAAC,WAAW,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAA,UAAU,CAAC,WAAW,CAAC,0CAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC5G,MAAM,GAAG,GAAG,CAAC,WAAW,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAA,UAAU,CAAC,WAAW,CAAC,0CAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAA;QAE3G,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SACxB;QACD,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SACxB;QACD,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SACxB;QACD,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SACxB;IACH,CAAC;IAED,gBAAgB,CAAC,MAAiB;QAChC,yBAAyB;QACzB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAErC,yEAAyE;QACzE,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE;YACtB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACtC,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;YAErB,oBAAoB;YACpB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;SAEpD;IACH,CAAC;IAED,eAAe,CAAC,UAAoB;QAClC,MAAM,IAAI,GAAG,EAAE,CAAC;QAChB,IAAI,UAAU,GAAG,EAAE,CAAC;QAEpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAE1C,kEAAkE;YAClE,+BAA+B;YAC/B,0BAA0B;YAC1B,mBAAmB;YACnB,4BAA4B;YAC5B,8BAA8B;YAC9B;;;;;gBAKI;YACJ,MAAM,MAAM,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAE7B,MAAM,cAAc,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACtD,MAAM,oBAAoB,GAAG,CAAC,cAAc,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC;YAC3D,MAAM,oBAAoB,GAAG,CAAC,cAAc,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC;YAC3D,MAAM,uBAAuB,GAAG,CAAC,cAAc,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;YAC7D,MAAM,mBAAmB,GAAG,CAAC,cAAc,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;YACzD,MAAM,kBAAkB,GAAG,cAAc,GAAG,GAAG,CAAC;YAEhD,+DAA+D;YAC/D,0BAA0B;YAC1B,sBAAsB;YACtB,sBAAsB;YAGtB,iEAAiE;YACjE,kDAAkD;YAGlD,yBAAyB;YACzB,IAAI,mBAAmB,IAAI,EAAE,IAAI,mBAAmB,IAAI,EAAE,EAAE;gBAC1D,oBAAoB;gBACpB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACnB;YAED,qBAAqB;iBAChB,IAAI,mBAAmB,IAAI,EAAE,EAAE;gBAClC,2DAA2D;gBAC3D,sCAAsC;gBACtC,OAAO,CAAC,GAAG,CAAC,sDAAsD,CAAC,CAAC;aACrE;YAGD,qBAAqB;iBAChB,IAAI,mBAAmB,IAAI,EAAE,EAAE;gBAClC,0CAA0C;gBAE1C,qBAAqB;gBACrB,sBAAsB;gBACtB,sBAAsB;gBACtB,sBAAsB;gBACtB,EAAE;gBAEF,kCAAkC;gBAClC,MAAM,WAAW,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAE,eAAe;gBAC7D,MAAM,WAAW,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAE,aAAa;gBAC3D,MAAM,WAAW,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,iCAAiC;gBAC9E,MAAM,cAAc,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,mBAAmB;gBAEnE,wEAAwE;gBAExE,4BAA4B;gBAC5B,IAAI,WAAW,IAAI,CAAC,IAAI,WAAW,IAAI,CAAC,EAAE;oBACxC,kBAAkB;oBAClB,qCAAqC;oBAErC,8BAA8B;oBAC9B,UAAU,GAAG,EAAE,CAAC;oBAEhB,yFAAyF;oBACzF,IAAI,UAAU,GAAG,CAAC,cAAc,GAAG,MAAM,CAAC,CAAC,CAAC,mDAAmD;oBAC/F,UAAU,GAAG,UAAU,GAAG,CAAC,cAAc,IAAI,CAAC,CAAC,CAAC,CAAC,yCAAyC;oBAE1F,UAAU,CAAC,IAAI,CAAC,CAAC,UAAU,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;oBAC1C,UAAU,CAAC,IAAI,CAAC,CAAC,UAAU,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;iBAC3C;gBAGD,sBAAsB;gBACtB,IAAI,IAAI,CAAC,QAAQ,EAAE;oBACjB,oCAAoC;oBACpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBACpC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,iDAAiD;qBAChF;iBACF;qBACI;oBACH,wBAAwB;oBACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBACtC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,iDAAiD;qBAC9E;iBACF;gBAED,IAAI,WAAW,IAAI,CAAC,IAAI,WAAW,IAAI,CAAC,EAAE;oBACxC,eAAe;oBACf,4CAA4C;oBAE5C,wCAAwC;oBACxC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;iBACpC;aACF;iBACI;gBACH,4EAA4E;aAC7E;SACF;QAED,yBAAyB;QACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;SAC5B;IACH,CAAC;CACF;AA/LD,gCA+LC","sourcesContent":["// Process SDP and RTP packets\n// De-packetize RTP packets to re-create H266 NAL Units\n// Write H266 NAL units to a .266 file\n\n// (c) 2026 Roger Hardiman\n// Based on my Yellowstone H265 Parser which in turn is based on my SharpRTSP H265 RTP Parser I wrote in September 2018\n\nimport RTSPClient from \"../RTSPClient\";\nimport { RTPPacket } from \"../util\";\n\nimport * as transform from \"sdp-transform\";\nimport { Writable } from \"stream\";\n\n// .h266 file header (Annex B)\nconst H266_HEADER = Buffer.from([0x00, 0x00, 0x00, 0x01]);\n\ninterface Details {\n  codec: string\n  mediaSource: transform.MediaDescription\n  rtpChannel: number,\n  rtcpChannel: number\n}\n\nexport default class H266Transport {\n  client: RTSPClient;\n  stream: Writable;\n  has_donl = false; // We have to check the SDP to see if DONL bytes are being set in the RTP packet\n\n  rtpPackets: Buffer[] = [];\n\n  constructor(client: RTSPClient, stream: Writable, details: Details) {\n    this.client = client;\n    this.stream = stream;\n\n    // process 'fmtp' (which is optional in the SDP)\n    this.processConnectionDetails(details);\n\n    client.on(\"data\", (channel, data, packet) => {\n      if (channel == details.rtpChannel) {\n        this.processRTPPacket(packet);\n      }\n    });\n\n  }\n\n  processConnectionDetails(details: Details): void {\n    // Extract the DCI, VPS, SPS and PPS from the MediaSource part of the SDP.\n    // NOTE the H266 RTP standard makes this optional and we may need to extract this from the RTP payload\n    // as inband DCI/VPS/SPS/PPS instead\n    const fmtp = (details.mediaSource.fmtp)[0];\n\n    if (!fmtp) {\n      return;\n    }\n\n    const fmtpConfig = transform.parseParams(fmtp.config);\n    const dci = ('sprop-dci' in fmtpConfig) ? Buffer.from(fmtpConfig['sprop-dci']?.toString(), \"base64\") : null;\n    const vps = ('sprop-vps' in fmtpConfig) ? Buffer.from(fmtpConfig['sprop-vps']?.toString(), \"base64\") : null; \n    const sps = ('sprop-sps' in fmtpConfig) ? Buffer.from(fmtpConfig['sprop-sps']?.toString(), \"base64\") : null;\n    const pps = ('sprop-pps' in fmtpConfig) ? Buffer.from(fmtpConfig['sprop-pps']?.toString(), \"base64\") : null\n\n    if (dci != null) {\n      this.stream.write(H266_HEADER);\n      this.stream.write(dci);\n    }\n    if (vps != null) {\n      this.stream.write(H266_HEADER);\n      this.stream.write(vps);\n    }\n    if (sps != null) {\n      this.stream.write(H266_HEADER);\n      this.stream.write(sps);\n    }\n    if (pps != null) {\n      this.stream.write(H266_HEADER);\n      this.stream.write(pps);\n    }\n  }\n\n  processRTPPacket(packet: RTPPacket): void {\n    // Accumatate RTP packets\n    this.rtpPackets.push(packet.payload);\n\n    // When Marker is set to 1 pass the group of packets to processRTPFrame()\n    if (packet.marker == 1) {\n      this.processRTPFrame(this.rtpPackets);\n      this.rtpPackets = [];\n\n      // Write out the AUD\n      this.stream.write(H266_HEADER);\n      this.stream.write(Buffer.from([0x00, 0xA1, 0x88]));\n\n    }\n  }\n\n  processRTPFrame(rtpPackets: Buffer[]): void {\n    const nals = [];\n    let partialNal = [];\n\n    for (let i = 0; i < rtpPackets.length; i++) {\n\n      // Examine the first two bytes of the RTP data, the Payload Header\n      // F (Forbidden Bit), must be 0\n      // Z (Zero Bit), must be 0\n      // LayerId (6 bits)\n      // Type of NAL Unit (5 bits)\n      // TID  (TemporalID = TID - 1)\n      /*+---------------+---------------+\n        *|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|\n        *+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        *|F|Z| LayerID   |  Type   | TID |\n        *+-------------+-----------------+\n        */\n      const packet = rtpPackets[i];\n\n      const payload_header = (packet[0] << 8) | (packet[1]);\n      const payload_header_f_bit = (payload_header >> 15) & 0x01;\n      const payload_header_z_bit = (payload_header >> 14) & 0x01;\n      const payload_header_layer_id = (payload_header >> 8) & 0x3F;\n      const payload_header_type = (payload_header >> 3) & 0x1F;\n      const payload_header_tid = payload_header & 0x7;\n\n      // There are three ways to Packetize NAL units into RTP Packets\n      //  Single NAL Unit Packet\n      //  Aggregation Packet\n      //  Fragmentation Unit\n\n\n      // Note H266/VVC has a concept of a GDR - Gradual Decoder Refresh\n      // and of the IDR - Instantaneous Decoding Refresh\n\n\n      // Single NAL Unit Packet\n      if (payload_header_type != 28 && payload_header_type != 29) {\n        //TODO - Handle DONL\n        nals.push(packet);\n      }\n\n      // Aggregation Packet\n      else if (payload_header_type == 28) {\n        // TODO. This is an Agregation Packet so we need to extract\n        // the 2 or more NALs from the packet.\n        console.log(\"eek - we have not implemented Agregation Packets yet\");\n      }\n\n\n      // Fragmentation Unit\n      else if (payload_header_type == 29) {\n        //Console.WriteLine(\"Fragmentation Unit\");\n\n        //    0 1 2 3 4 5 6 7\n        //   +-+-+-+-+-+-+-+-+\n        //   |S|E|P| FuType  |\n        //   +---------------+\n        //\n\n        // Parse Fragmentation Unit Header\n        const fu_header_s = (packet[2] >> 7) & 0x01;  // start marker\n        const fu_header_e = (packet[2] >> 6) & 0x01;  // end marker\n        const fu_header_p = (packet[2] >> 5) & 0x01; // P = last FU of a Coded Picture\n        const fu_header_type = (packet[2] >> 0) & 0x1F; // fu type (5 bits)\n\n        // Console.WriteLine(\"Frag FU-A s=\" + fu_header_s + \"e=\" + fu_header_e);\n\n        // Check Start and End flags\n        if (fu_header_s == 1 && fu_header_e == 0) {\n          // Start Fragment.\n          // Initiise the partialNal byte array\n\n          // Empty the partial NAL array\n          partialNal = [];\n\n          // Reconstrut the NAL header from the rtp_payload_header, replacing the Type with FU Type\n          let nal_header = (payload_header & 0xFF07); // strip out existing 'type' which is the \"FU Type\"\n          nal_header = nal_header | (fu_header_type << 3); // and replace it with the fu_header_type\n\n          partialNal.push((nal_header >> 8) & 0xFF);\n          partialNal.push((nal_header >> 0) & 0xFF);\n        }\n\n\n        // Copy the video data\n        if (this.has_donl) {\n          // start copying after the DONL data\n          for (let x = 5; x < packet.length; x++) {\n              partialNal.push(packet[x]); // not very efficient, copying one byte at a time\n          }\n        }\n        else {\n          // there is no DONL data\n          for (let x = 3; x < packet.length; x++) {\n            partialNal.push(packet[x]); // not very efficient, copying one byte at a time\n          }\n        }\n\n        if (fu_header_s == 0 && fu_header_e == 1) {\n          // End Fragment\n          // Append this payload to the fragmented_nal\n\n          // Add the NAL to the array of NAL units\n          nals.push(Buffer.from(partialNal));\n        }\n      }\n      else {\n        //Console.WriteLine(\"Unknown Payload Header Type = \" + payload_header_type);\n      }\n    }\n\n    // Write out all the NALs\n    for (let x = 0; x < nals.length; x++) {\n      this.stream.write(H266_HEADER);\n      this.stream.write(nals[x]);\n    }\n  }\n}\n"]}