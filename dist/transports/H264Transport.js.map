{"version":3,"file":"H264Transport.js","sourceRoot":"","sources":["../../lib/transports/H264Transport.ts"],"names":[],"mappings":"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","sourcesContent":["// Process SDP and RTP packets\r\n// De-packetize RTP packets to re-create H264 NAL Units\r\n// Write H264 NAL units to a .264 file\r\n\r\nimport RTSPClient from \"../RTSPClient\";\r\nimport {RTPPacket} from \"../util\";\r\n\r\nimport * as transform from \"sdp-transform\";\r\nimport { Writable } from \"stream\";\r\n\r\n// .h264 file header\r\nconst H264_HEADER = Buffer.from([0x00,0x00,0x00,0x01]);\r\n\r\ninterface Details {\r\n  codec: string\r\n  mediaSource: transform.MediaDescription\r\n  rtpChannel: number,\r\n  rtcpChannel: number\r\n}\r\n\r\nexport default class H264Transport {\r\n  client: RTSPClient;\r\n  stream: Writable;\r\n\r\n  rtpPackets: Buffer[] = [];\r\n\r\n  _headerWritten = false;\r\n\r\n  constructor(client: RTSPClient, stream: Writable, details: Details) {\r\n    this.client = client;\r\n    this.stream = stream;\r\n\r\n    client.on(\"data\", (channel, data, packet) => {\r\n      if (channel == details.rtpChannel) {\r\n        if (this._headerWritten) {\r\n          this.processRTPPacket(packet);\r\n        }\r\n      }\r\n    });\r\n\r\n    this.processConnectionDetails(details);\r\n  }\r\n\r\n  processConnectionDetails(details: Details): void {\r\n    // Extract SPS and PPS from the MediaSource part of the SDP\r\n    const fmtp = (details.mediaSource.fmtp)[0];\r\n    \r\n    if (!fmtp) {\r\n      return;\r\n    }\r\n  \r\n    const fmtpConfig = transform.parseParams(fmtp.config);\r\n    const splitSpropParameterSets = fmtpConfig['sprop-parameter-sets'].toString().split(',');\r\n    const sps_base64 = splitSpropParameterSets[0];\r\n    const pps_base64 = splitSpropParameterSets[1];\r\n    const sps = Buffer.from(sps_base64, \"base64\");\r\n    const pps = Buffer.from(pps_base64, \"base64\");\r\n\r\n    this.stream.write(H264_HEADER);\r\n    this.stream.write(sps);\r\n    this.stream.write(H264_HEADER);\r\n    this.stream.write(pps);\r\n\r\n    this._headerWritten = true;\r\n  }\r\n\r\n  processRTPPacket(packet: RTPPacket): void {\r\n    // Accumatate RTP packets\r\n    this.rtpPackets.push(packet.payload);\r\n    \r\n    // When Marker is set to 1 pass the group of packets to processRTPFrame()\r\n    if (packet.marker == 1) {\r\n      this.processRTPFrame(this.rtpPackets);\r\n      this.rtpPackets = [];\r\n    }\r\n  }\r\n\r\n  processRTPFrame(rtpPackets: Buffer[]): void {\r\n    const nals = [];\r\n    let partialNal = [];\r\n\r\n    for (let i = 0; i < rtpPackets.length; i++) {\r\n      const packet = rtpPackets[i];\r\n      const nal_header_f_bit = (packet[0] >> 7) & 0x01;\r\n      const nal_header_nri = (packet[0] >> 5) & 0x03;\r\n      const nal_header_type = (packet[0] >> 0) & 0x1F;\r\n\r\n      if (nal_header_type >= 1 && nal_header_type <= 23) { // Normal NAL. Not fragmented\r\n        nals.push(packet);\r\n      } else if (nal_header_type == 24) { // Aggregation type STAP-A. Multiple NAls in one RTP Packet\r\n        let ptr = 1; // start after the nal_header_type which was '24'\r\n        // if we have at least 2 more bytes (the 16 bit size) then consume more data\r\n        while (ptr + 2 < (packet.length - 1)) {\r\n          const size = (packet[ptr] << 8) + (packet[ptr + 1] << 0);\r\n          ptr = ptr + 2;\r\n          nals.push(packet.slice(ptr,ptr+size));\r\n          ptr = ptr + size;\r\n        }\r\n      } else if (nal_header_type == 25) { // STAP-B\r\n        // Not supported\r\n      } else if (nal_header_type == 26) { // MTAP-16\r\n        // Not supported\r\n      } else if (nal_header_type == 27) { // MTAP-24\r\n        // Not supported\r\n      } else if (nal_header_type == 28) { // Frag FU-A\r\n        // NAL is split over several RTP packets\r\n        // Accumulate them in a tempoary buffer\r\n        // Parse Fragmentation Unit Header\r\n        const fu_header_s = (packet[1] >> 7) & 0x01;  // start marker\r\n        const fu_header_e = (packet[1] >> 6) & 0x01;  // end marker\r\n        const fu_header_r = (packet[1] >> 5) & 0x01;  // reserved. should be 0\r\n        const fu_header_type = (packet[1] >> 0) & 0x1F; // Original NAL unit header\r\n\r\n        // Check Start and End flags\r\n        if (fu_header_s == 1 && fu_header_e == 0) { // Start of Fragment}\r\n          const reconstructed_nal_type = (nal_header_f_bit << 7)\r\n                                        + (nal_header_nri << 5)\r\n                                        + fu_header_type;\r\n          partialNal = [];\r\n          partialNal.push(reconstructed_nal_type);\r\n\r\n          // copy the rest of the RTP payload to the temp buffer\r\n          for (let x=2; x< packet.length;x++) partialNal.push(packet[x]);\r\n        }\r\n\r\n        if (fu_header_s == 0 && fu_header_e == 0) { // Middle part of fragment}\r\n          for (let x=2; x< packet.length;x++) partialNal.push(packet[x]);\r\n        }\r\n\r\n        if (fu_header_s == 0 && fu_header_e == 1) { // End of fragment}\r\n          for (let x=2; x< packet.length;x++) partialNal.push(packet[x]);\r\n          nals.push(Buffer.from(partialNal));\r\n        }\r\n      } else if (nal_header_type == 29) { // Frag FU-B\r\n        // Not supported\r\n      }\r\n    }\r\n\r\n    // Write out all the NALs\r\n    for (let x = 0; x < nals.length; x++) {\r\n        this.stream.write(H264_HEADER);\r\n        this.stream.write(nals[x]);\r\n    }\r\n  }\r\n}\r\n"]}