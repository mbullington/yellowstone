{"version":3,"file":"H264Transport.js","sourceRoot":"","sources":["../../lib/transports/H264Transport.ts"],"names":[],"mappings":"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","sourcesContent":["// Process SDP and RTP packets\n// De-packetize RTP packets to re-create H264 NAL Units\n// Write H264 NAL units to a .264 file\n\nimport RTSPClient from \"../RTSPClient\";\nimport {RTPPacket} from \"../util\";\n\nimport * as transform from \"sdp-transform\";\nimport { Writable } from \"stream\";\n\n// .h264 file header\nconst H264_HEADER = Buffer.from([0x00,0x00,0x00,0x01]);\n\ninterface Details {\n  mediaSource: transform.MediaDescription\n};\n\nexport default class H264Transport {\n  client: RTSPClient;\n  stream: Writable;\n\n  rtpPackets: Buffer[] = [];\n\n  _headerWritten: boolean = false;\n\n  constructor(client: RTSPClient, stream: Writable, details?: Details) {\n    this.client = client;\n    this.stream = stream;\n\n    client.on(\"data\", (channel, data, packet) => {\n      if (this._headerWritten) {\n        this.processRTPPacket(packet);\n      }\n    });\n\n    if (details != null) {\n      this.processConnectionDetails(details);\n    }\n  }\n\n  processConnectionDetails(details: Details) {\n    // Extract SPS and PPS from the MediaSource part of the SDP\n    const fmtp = (details.mediaSource.fmtp as any)[0];\n    \n    if (!fmtp) {\n      return;\n    }\n  \n    const fmtpConfig = transform.parseParams(fmtp.config);\n    const splitSpropParameterSets = fmtpConfig['sprop-parameter-sets'].toString().split(',');\n    const sps_base64 = splitSpropParameterSets[0];\n    const pps_base64 = splitSpropParameterSets[1];\n    const sps = new Buffer(sps_base64, \"base64\");\n    const pps = new Buffer(pps_base64, \"base64\");\n\n    this.stream.write(H264_HEADER);\n    this.stream.write(sps);\n    this.stream.write(H264_HEADER);\n    this.stream.write(pps);\n\n    this._headerWritten = true;\n  };\n\n  processRTPPacket(packet: RTPPacket) {\n    // Accumatate RTP packets\n    this.rtpPackets.push(packet.payload);\n    \n    // When Marker is set to 1 pass the group of packets to processRTPFrame()\n    if (packet.marker == 1) {\n      this.processRTPFrame(this.rtpPackets);\n      this.rtpPackets = [];\n    }\n  }\n\n  processRTPFrame(rtpPackets: Buffer[]) {\n    const nals = [];\n    let partialNal = [];\n\n    for (let i = 0; i < rtpPackets.length; i++) {\n      const packet = rtpPackets[i];\n      const nal_header_f_bit = (packet[0] >> 7) & 0x01;\n      const nal_header_nri = (packet[0] >> 5) & 0x03;\n      const nal_header_type = (packet[0] >> 0) & 0x1F;\n\n      if (nal_header_type >= 1 && nal_header_type <= 23) { // Normal NAL. Not fragmented\n        nals.push(packet);\n      } else if (nal_header_type == 24) { // Aggregation type STAP-A. Multiple NAls in one RTP Packet\n        let ptr = 1; // start after the nal_header_type which was '24'\n        // if we have at least 2 more bytes (the 16 bit size) then consume more data\n        while (ptr + 2 < (packet.length - 1)) {\n          let size = (packet[ptr] << 8) + (packet[ptr + 1] << 0);\n          ptr = ptr + 2;\n          nals.push(packet.slice(ptr,ptr+size));\n          ptr = ptr + size;\n        }\n      } else if (nal_header_type == 25) { // STAP-B\n        // Not supported\n      } else if (nal_header_type == 26) { // MTAP-16\n        // Not supported\n      } else if (nal_header_type == 27) { // MTAP-24\n        // Not supported\n      } else if (nal_header_type == 28) { // Frag FU-A\n        // NAL is split over several RTP packets\n        // Accumulate them in a tempoary buffer\n        // Parse Fragmentation Unit Header\n        const fu_header_s = (packet[1] >> 7) & 0x01;  // start marker\n        const fu_header_e = (packet[1] >> 6) & 0x01;  // end marker\n        const fu_header_r = (packet[1] >> 5) & 0x01;  // reserved. should be 0\n        const fu_header_type = (packet[1] >> 0) & 0x1F; // Original NAL unit header\n\n        // Check Start and End flags\n        if (fu_header_s == 1 && fu_header_e == 0) { // Start of Fragment}\n          const reconstructed_nal_type = (nal_header_f_bit << 7)\n                                        + (nal_header_nri << 5)\n                                        + fu_header_type;\n          partialNal = [];\n          partialNal.push(reconstructed_nal_type);\n\n          // copy the rest of the RTP payload to the temp buffer\n          for (let x=2; x< packet.length;x++) partialNal.push(packet[x]);\n        }\n\n        if (fu_header_s == 0 && fu_header_e == 0) { // Middle part of fragment}\n          for (let x=2; x< packet.length;x++) partialNal.push(packet[x]);\n        }\n\n        if (fu_header_s == 0 && fu_header_e == 1) { // End of fragment}\n          for (let x=2; x< packet.length;x++) partialNal.push(packet[x]);\n          nals.push(Buffer.from(partialNal));\n        }\n      } else if (nal_header_type == 29) { // Frag FU-B\n        // Not supported\n      }\n    }\n\n    // Write out all the NALs\n    for (let x = 0; x < nals.length; x++) {\n        this.stream.write(H264_HEADER);\n        this.stream.write(nals[x]);\n    }\n  }\n}\n"]}