{"version":3,"file":"RTSPClient.js","sourceRoot":"","sources":["../lib/RTSPClient.ts"],"names":[],"mappings":"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","sourcesContent":["import * as net from \"net\";\nimport * as tls from \"tls\";\n\n// Union of net.Socket and tls.TLSSocket\ntype SocketUnion = net.Socket | tls.TLSSocket;\n\nimport * as dgram from \"dgram\";\nimport { parse as urlParse } from \"url\";\nimport { EventEmitter } from \"events\";\n\nimport * as util from \"./util\";\n\nimport {\n  parseRTPPacket,\n  parseRTCPPacket,\n  getMD5Hash,\n  getSHA256Hash,\n  Transport,\n  parseTransport,\n  generateSSRC,\n} from \"./util\";\n\nimport * as transform from \"sdp-transform\";\nimport RTPPacket from \"./transports/RTPPacket\";\nconst RTP_AVP = \"RTP/AVP\";\nconst RTP_AVPF = \"RTP/AVPF\"; // Used by AV1. This is RTP with Feedback (via RTCP) to request Keyframes via RTCP\n\nconst STATUS_OK = 200;\nconst STATUS_UNAUTH = 401;\n\n// The WWW_AUTH is of the format\n//      TOKEN key=value\n//      TOKEN key1=value1,key2=value2\n//      TOKEN key1=\"value1\",key2=value2\n\n// RegEx reminder ? = Zero or One item\n//                * = Zero or More items\n//                + = 1 or More items\n//                \\s is whitespace. But we need to 'escape the slash', hence \\\\s (or put the regex in / / characters)\n//                ?= is a lookahead\n\n// The RegEx has two 'Groups'\n//      \n// Group 1 (finding the Key)\n//    Look for one or more characters (a..z or A..Z)\n//    then look for whitespace\n//    then look for 'equals'\n//    then look for whitespace\n//    then look for an optional Quote character\n//\n// Group 2 (finding the Value) -\n//    Look for EITHER 'look backwards for a Quote', some characters, 'lookahead for a Quote'\n//                 OR some characters until (by looking ahead) you can see that another key comes next. The lookahead is 'optinal whitespace' 'comma' 'optional whitespace' 'chars' 'optinal whitespace' 'equals'\n//                 OR some characters followed by 'optinal whitespace'\n\nconst WWW_AUTH = \"WWW-Authenticate\";\nconst WWW_AUTH_REGEX = new RegExp('([a-zA-Z]+)\\\\s*=\\\\s*\"?((?<=\").*?(?=\")|.*?(?=\\\\s*,?\\\\s*[a-zA-Z]+\\\\s*=)|.+[^\\\\s])', \"g\");\n\nenum ReadStates {\n  SEARCHING,\n  READING_RTSP_HEADER,\n  READING_RTSP_PAYLOAD,\n  READING_RAW_PACKET_SIZE,\n  READING_RAW_PACKET,\n}\n\ntype Connection = \"udp\" | \"tcp\";\n\ntype Headers = {\n  [key: string]: string | number | undefined;\n  Session?: string;\n  Location?: string;\n  CSeq?: number;\n  \"WWW-Authenticate\"?: string;\n  Transport?: string;\n  Unsupported?: string;\n};\n\n// Details for each Session within the RTSP Stream (eg video session, audio session, metadata session)\ntype Detail = {\n  codec: string;\n  mediaSource: ({ // cannot work out how to pull this type in\n                type: string;\n                port: number;\n                protocol: string;\n                payloads?: string | undefined;\n                } & transform.MediaDescription); // get Type from the interface\n  transport: Transport['parameters']; // get Type from the interface\n  isH264: boolean; // legacy API\n  rtpChannel: number;\n  rtcpChannel: number;\n\n  // Cache any optional RTCP Sender Report values (used to calculate Wall Clock Time)\n  sr_ntpMSW?: number;\n  sr_ntpLSW?: number;\n  sr_rtptimestamp?: number;\n};\n\nexport default class RTSPClient extends EventEmitter {\n  username: string;\n  password: string;\n  headers: { [key: string]: string };\n\n  isConnected = false;\n  closed = false;\n\n  // These are all set in #connect or #_netConnect.\n\n  _url?: string;\n  _client?: SocketUnion;\n  _cSeq = 0;\n  _unsupportedExtensions?: string[];\n  // Example: 'SessionId'[';timeout=seconds']\n  _session?: string;\n  _keepAliveID?: NodeJS.Timeout;\n  _nextFreeInterleavedChannel = 0;\n  _nextFreeUDPPort = 5000;\n\n  readState: ReadStates = ReadStates.SEARCHING;\n\n  // Used as a cache for the data stream.\n  // What's in here is based on current #readState.\n  messageBytes: number[] = [];\n\n  // Used for parsing RTSP responses,\n\n  // Content-Length header in the RTSP message.\n  rtspContentLength = 0;\n  rtspStatusLine = \"\";\n  rtspHeaders: Headers = {};\n\n  // Used for parsing RTP/RTCP responses.\n\n  rtspPacketLength = 0;\n  rtspPacket = Buffer.from(\"\");\n  rtspPacketPointer = 0;\n\n  // Used in #_emptyReceiverReport.\n  clientSSRC = generateSSRC();\n\n  tcpSocket: SocketUnion = new net.Socket();\n  setupResult: Array<Detail> = [];\n  constructor(\n    username: string,\n    password: string,\n    headers?: { [key: string]: string }\n  ) {\n    super();\n\n    this.username = username;\n    this.password = password;\n    this.headers = {\n      ...(headers || {}),\n      \"User-Agent\": \"yellowstone/3.x\",\n    };\n  }\n\n  // This manages the lifecycle for the RTSP connection\n  // over TCP.\n  //\n  // Sets #_client.\n  //\n  // Handles receiving data & closing port, called during\n  // #connect.\n  _netConnect(hostname: string, port: number, secure = false): Promise<this> {\n    return new Promise((resolve, reject) => {\n      // Set after listeners defined.\n\n      const errorListener = (err: Error) => {\n        client.removeListener(\"error\", errorListener);\n        reject(err);\n      };\n\n      const postConnectErrorListener = (err: Error) => {\n        client.removeListener(\"error\", postConnectErrorListener);\n        this.emit(\"error\", err);\n        reject(err);\n      };\n\n      const closeListener = () => {\n        client.removeListener(\"close\", closeListener);\n        this.emit(\"close\");\n        this.close(true);\n      };\n\n      const responseListener = (responseName: string, headers: Headers) => {\n        const name = responseName.split(\" \")[0];\n\n        if (name.indexOf(\"RTSP/\") === 0) {\n          return;\n        }\n\n        if (name === \"REDIRECT\" || name === \"ANNOUNCE\") {\n          this.respond(\"200 OK\", { CSeq: headers.CSeq });\n        }\n\n        if (name === \"REDIRECT\" && headers.Location) {\n          this.close();\n          this.connect(headers.Location);\n        }\n      };\n\n      // rtsp or rtsps(with tls)\n      let client: SocketUnion;\n      if (secure == false) {\n        client = net.connect(port, hostname, () => {\n          this.isConnected = true;\n          this._client = client;\n\n          client.removeListener(\"error\", errorListener);\n          client.on(\"error\", postConnectErrorListener);\n\n          this.on(\"response\", responseListener);\n          resolve(this);\n        });\n      }\n      else {\n        const options: tls.ConnectionOptions = {\n          rejectUnauthorized: false\n        };\n        client = tls.connect(port, hostname, options, () => {\n          console.log(\"TLS Connection\");\n          this.isConnected = true;\n          this._client = client;\n\n          client.removeListener(\"error\", errorListener);\n\n          this.on(\"response\", responseListener);\n          resolve(this);\n        });\n      }\n\n      client.on(\"data\", this._onData.bind(this));\n      client.on(\"error\", errorListener);\n      client.on(\"close\", closeListener);\n      this.tcpSocket = client;\n    });\n  }\n\n  async connect(\n    url: string,\n    {\n      keepAlive = true,\n      connection = \"udp\",\n      secure = false,\n    }: { keepAlive: boolean; connection?: Connection, secure: boolean } = {\n        keepAlive: true,\n        connection: \"udp\",\n        secure: false\n      }\n  ): Promise<Detail[]> {\n    const { hostname, port } = urlParse((this._url = url));\n    if (!hostname) {\n      throw new Error(\"URL parsing error in connect method.\");\n    }\n\n    const details: Detail[] = [];\n\n    await this._netConnect(hostname, parseInt(port || \"554\"), secure);\n    await this.request(\"OPTIONS\");\n\n    const describeRes = await this.request(\"DESCRIBE\", {\n      Accept: \"application/sdp\",\n    });\n    if (!describeRes || !describeRes.mediaHeaders) {\n      throw new Error(\n        \"No media headers on DESCRIBE; RTSP server is broken (sanity check)\"\n      );\n    }\n\n    // For now, only RTP/AVP and RTP/AVPF are supported. (Some RTSPS servers use RTP/SAVP)\n    const { media } = transform.parse(describeRes.mediaHeaders.join(\"\\r\\n\"));\n\n    // Loop over the Media Streams in the SDP looking for Video or Audio\n    // In theory the SDP can contain multiple Video and Audio Streams. We only want one of each type\n    let hasVideo = false;\n    let hasAudio = false;\n    let hasMetaData = false;\n    let hasBackchannel = false;\n\n    for (let x = 0; x < media.length; x++) {\n      let needSetup = false;\n      let codec = \"\";\n      const mediaSource = media[x];\n\n\n      // RFC says \"If none of the direction attributes (\"sendonly\", \"recvonly\", \"inactive\", and \"sendrecv\") are present,\n      // the \"sendrecv\" SHOULD be assumed\n      if (mediaSource.direction == undefined) mediaSource.direction = \"sendrecv\"; //  Wowza does not send 'direction'\n\n      if (\n        mediaSource.type === \"video\" &&\n        mediaSource.protocol === RTP_AVP &&\n        mediaSource.rtp[0].codec === \"H264\"\n      ) {\n        this.emit(\"log\", \"H264 Video Stream Found in SDP\", \"\");\n        if (hasVideo == false) {\n          needSetup = true;\n          hasVideo = true;\n          codec = \"H264\";\n        }\n      }\n\n      if (\n        mediaSource.type === \"video\" &&\n        mediaSource.protocol === RTP_AVP &&\n        mediaSource.rtp[0].codec === \"H265\"\n      ) {\n        this.emit(\"log\", \"H265 Video Stream Found in SDP\", \"\");\n        if (hasVideo == false) {\n          needSetup = true;\n          hasVideo = true;\n          codec = \"H265\";\n        }\n      }\n\n      if (\n        mediaSource.type === \"video\" &&\n        (mediaSource.protocol === RTP_AVP || mediaSource.protocol === RTP_AVPF) &&\n        mediaSource.rtp[0].codec === \"AV1\"\n      ) {\n        this.emit(\"log\", \"AV1 Video Stream Found in SDP\", \"\");\n        if (hasVideo == false) {\n          needSetup = true;\n          hasVideo = true;\n          codec = \"AV1\";\n        }\n      }\n\n\n      if (\n        mediaSource.type === \"audio\" &&\n        (mediaSource.direction === \"recvonly\" || mediaSource.direction === \"sendrecv\") &&\n        mediaSource.protocol === RTP_AVP &&\n        mediaSource.rtp[0].codec.toLowerCase() === \"mpeg4-generic\" && // (RFC examples are lower case. Axis cameras use upper case)\n        mediaSource.fmtp[0].config.includes(\"AAC\")\n      ) {\n        this.emit(\"log\", \"AAC Audio Stream Found in SDP\", \"\");\n        if (hasAudio == false) {\n          needSetup = true;\n          hasAudio = true;\n          codec = \"AAC\";\n        }\n      }\n\n      if (mediaSource.type === \"audio\" &&\n        mediaSource.direction === \"sendonly\" &&\n        mediaSource.protocol === RTP_AVP) {\n        this.emit(\"log\", \"Audio backchannel Found in SDP\", \"\");\n        if (hasBackchannel == false) {\n          needSetup = true;\n          hasBackchannel = true;\n          codec = mediaSource.rtp[0].codec;\n        }\n      }\n\n      if (\n        mediaSource.type === \"application\" &&\n        mediaSource.protocol === RTP_AVP &&\n        mediaSource.rtp[0].codec.toLowerCase() === \"vnd.onvif.metadata\"\n      ) {\n        this.emit(\"log\", \"ONVIF Meta Data Found in SDP\", \"\");\n        if (hasMetaData == false) {\n          needSetup = true;\n          hasMetaData = true;\n          codec = \"vnd.onvif.metadata\";\n        }\n      }\n\n      if (needSetup) {\n        let streamurl = \"\";\n        // The 'control' in the SDP can be a relative or absolute uri\n        if (mediaSource.control) {\n          if (mediaSource.control.toLowerCase().startsWith(\"rtsp://\")) {\n            // absolute path\n            streamurl = mediaSource.control;\n          } else {\n            // relative path\n            streamurl = this._url + \"/\" + mediaSource.control;\n          }\n        }\n\n        // Perform a SETUP on the streamurl\n        // either 'udp' RTP/RTCP packets\n        // or with 'tcp' RTP/TCP packets which are interleaved into the TCP based RTSP socket\n        let setupRes;\n        let rtpChannel: number;\n        let rtcpChannel: number;\n        let rtpReceiver: dgram.Socket|null = null; // UDP mode init value\n        let rtcpReceiver: dgram.Socket|null = null; // UDP mode init value\n\n        if (connection === \"udp\") {\n          // Create a pair of UDP listeners, even numbered port for RTP\n          // and odd numbered port for RTCP\n\n          rtpChannel = this._nextFreeUDPPort;\n          rtcpChannel = this._nextFreeUDPPort + 1;\n          this._nextFreeUDPPort += 2;\n\n          const rtpPort = rtpChannel;\n          rtpReceiver = dgram.createSocket(\"udp4\");\n\n          rtpReceiver.on(\"message\", (buf) => {\n            const packet = parseRTPPacket(buf);\n\n            // Add wall clock time\n            const detail = this.setupResult.find(item => item.rtpChannel == rtpChannel);\n            if (detail != undefined) packet.wallclockTime = this.GetWallClockTime(packet, detail);\n\n            this.emit(\"data\", rtpPort, packet.payload, packet);\n          });\n\n          const rtcpPort = rtcpChannel;\n          rtcpReceiver = dgram.createSocket(\"udp4\");\n\n          rtcpReceiver.on(\"message\", (buf, remote) => {\n            const packet = parseRTCPPacket(buf);\n\n            // If this is a Sender Report, cache the NTP Wall Clock data\n            if (packet.packetType == 200 && packet.senderReport != undefined) {\n              const detail = this.setupResult.find(item => item.rtcpChannel == rtcpChannel);\n              if (detail != undefined) {\n                detail.sr_ntpMSW = packet.senderReport.ntpTimestampMSW;\n                detail.sr_ntpLSW = packet.senderReport.ntpTimestampLSW;\n                detail.sr_rtptimestamp = packet.senderReport.rtpTimestamp;\n              }\n            }\n\n            this.emit(\"controlData\", rtcpPort, packet);\n\n            const receiver_report = this._emptyReceiverReport();\n            this._sendUDPData(remote.address, remote.port, receiver_report);\n          });\n\n          // Block until both UDP sockets are open.\n\n          await new Promise((resolve) => {\n            rtpReceiver?.bind(rtpPort, () => resolve({}));\n          });\n\n          await new Promise((resolve) => {\n            rtcpReceiver?.bind(rtcpPort, () => resolve({}));\n          });\n\n          const setupHeader = {\n            Transport: `RTP/AVP;unicast;client_port=${rtpPort}-${rtcpPort}`,\n          };\n          if (this._session)\n            Object.assign(setupHeader, { Session: this._session });\n          setupRes = await this.request(\"SETUP\", setupHeader, streamurl);\n        } else if (connection === \"tcp\") {\n          // channel 0, RTP\n          // channel 1, RTCP\n\n          rtpChannel = this._nextFreeInterleavedChannel;\n          rtcpChannel = this._nextFreeInterleavedChannel + 1;\n          this._nextFreeInterleavedChannel += 2;\n\n          const setupHeader = {\n            Transport: `RTP/AVP/TCP;interleaved=${rtpChannel}-${rtcpChannel}`,\n          };\n          if (this._session)\n            Object.assign(setupHeader, { Session: this._session }); // not used on first SETUP\n          setupRes = await this.request(\"SETUP\", setupHeader, streamurl);\n        } else {\n          throw new Error(\n            `Connection parameter to RTSPClient#connect is ${connection}, not udp or tcp!`\n          );\n        }\n\n        if (!setupRes) {\n          throw new Error(\n            \"No SETUP response; RTSP server is broken (sanity check)\"\n          );\n        }\n\n        const { headers } = setupRes;\n\n        if (!headers.Transport) {\n          throw new Error(\n            \"No Transport header on SETUP; RTSP server is broken (sanity check)\"\n          );\n        }\n\n        const transport = parseTransport(headers.Transport);\n        if (\n          transport.protocol !== \"RTP/AVP/TCP\" &&\n          transport.protocol !== \"RTP/AVP\"\n        ) {\n          throw new Error(\n            \"Only RTSP servers supporting RTP/AVP(unicast) or RTP/AVP/TCP are supported at this time.\"\n          );\n        }\n\n        // Patch from zoolyka (Zoltan Hajdu).\n        // Try to open a hole in the NAT router (to allow incoming UDP packets)\n        // by send a UDP packet for RTP and RTCP to the remote RTSP server.\n        // Note, Roger did not have a router that needed this so the feature is untested.\n        // May be better to change the RTCP message to a Receiver Report, leaving the RTP message as zero bytes\n        if (connection === \"udp\" && transport && rtpReceiver && rtcpReceiver) {\n          rtpReceiver.send(Buffer.from(''), Number(transport.parameters[\"server_port\"].split(\"-\")[0]), hostname);\n          rtcpReceiver.send(Buffer.from(''), Number(transport.parameters[\"server_port\"].split(\"-\")[1]), hostname);\n        }\n\n        if (headers.Unsupported) {\n          this._unsupportedExtensions = headers.Unsupported.split(\",\");\n        }\n\n        if (headers.Session) {\n          this._session = headers.Session.split(\";\")[0];\n        }\n\n        const detail: Detail = {\n          codec,\n          mediaSource,\n          transport: transport.parameters,\n          isH264: codec === \"H264\", // legacy API\n          rtpChannel,\n          rtcpChannel,\n        };\n\n        details.push(detail);\n      } // end if (needSetup)\n    } // end for loop, looping over each media stream\n\n    if (keepAlive) {\n      // Start a Timer to send OPTIONS every 20 seconds to keep stream alive\n      // using the Session ID\n      this._keepAliveID = setInterval(() => {\n        this.request(\"OPTIONS\", { Session: this._session });\n        //        this.request(\"OPTIONS\");\n      }, 20 * 1000);\n    }\n\n    this.setupResult = details;\n    return details;\n  }\n\n  request(\n    requestName: string,\n    headersParam: Headers = {},\n    url?: string\n  ): Promise<{ headers: Headers; mediaHeaders?: string[] } | void> {\n    if (!this._client) {\n      return Promise.resolve();\n    }\n\n    const id = ++this._cSeq;\n    // mutable via string addition\n    let req = `${requestName} ${url || this._url} RTSP/1.0\\r\\nCSeq: ${id}\\r\\n`;\n\n    const headers = {\n      ...this.headers,\n      ...headersParam,\n    };\n\n    // NOTE:\n    // If we cache the Authenitcation Type (Direct or Basic) then we could\n    // re-compute an Authorization Header here and include in the RTSP Command\n    // This would make connections a faster with fewer round-trips to the RTSP Server\n\n    req += Object.entries(headers)\n      .map(([key, value]) => `${key}: ${value}\\r\\n`)\n      .join(\"\");\n\n    this.emit(\"log\", req, \"C->S\");\n    // Make sure to add an empty line after the request.\n    this._client.write(`${req}\\r\\n`);\n\n    return new Promise((resolve, reject) => {\n      const responseHandler = (\n        responseName: string,\n        resHeaders: Headers,\n        mediaHeaders: string[]\n      ) => {\n        const firstAnswer: string = String(resHeaders[\"\"]) || \"\";\n        if (firstAnswer.indexOf(\"401\") >= 0 && 'Authorization' in headers) {\n          // If the RTSP Command we sent included an Authorization and we have 401 error, then reject()\n          reject(new Error(`Bad RTSP credentials!`));\n          return;\n        }\n        if (resHeaders.CSeq !== id) {\n          return;\n        }\n\n        this.removeListener(\"response\", responseHandler);\n\n        const statusCode = parseInt(responseName.split(\" \")[1]);\n\n        if (statusCode === STATUS_OK) {\n          if (mediaHeaders.length > 0) {\n            resolve({\n              headers: resHeaders,\n              mediaHeaders,\n            });\n          } else {\n            resolve({\n              headers: resHeaders,\n            });\n          }\n        } else {\n          const authHeader = resHeaders[WWW_AUTH];\n\n          // We have status code unauthenticated.\n          if (statusCode === STATUS_UNAUTH && authHeader) {\n            const type = authHeader.split(\" \")[0];\n\n            // Get auth properties from WWW_AUTH header.\n            let realm = \"\";\n            let nonce = \"\";\n            let algorithm = \"MD5\"; // Default to MD5 if no algorthm is given. Milestone's RTSP server also supports SHA-256 for FIPS\n\n            let match = WWW_AUTH_REGEX.exec(authHeader);\n            while (match != null) {\n              const prop = match[1];\n\n              if (prop == \"realm\" && match[2]) {\n                realm = match[2];\n              }\n\n              if (prop == \"nonce\" && match[2]) {\n                nonce = match[2];\n              }\n\n              if (prop == \"algorithm\" && match[2]) {\n                algorithm = match[2];\n              }\n\n              match = WWW_AUTH_REGEX.exec(authHeader);\n            }\n\n            // mutable, corresponds to Authorization header\n            let authString = \"\";\n\n            if (type === \"Digest\") {\n              // Digest Authentication\n\n              // Select Hash Function, default to MD5\n              const HashFunction = (algorithm == \"SHA-256\" ? getSHA256Hash : getMD5Hash);\n\n              const ha1 = HashFunction(\n                `${this.username}:${realm}:${this.password}`\n              );\n              const ha2 = HashFunction(`${requestName}:${this._url}`);\n              const ha3 = HashFunction(`${ha1}:${nonce}:${ha2}`);\n\n              // Some RTSP servers to not accept \"algorithm=NNN\" in the authString and reject the authentication. So only add algorithm=ZZZZ when not using MD5\n              if (algorithm == \"MD5\")\n                authString = `Digest username=\"${this.username}\",realm=\"${realm}\",nonce=\"${nonce}\",uri=\"${this._url}\",response=\"${ha3}\"`;\n              else\n                authString = `Digest username=\"${this.username}\",realm=\"${realm}\",nonce=\"${nonce}\",algorithm=${algorithm},uri=\"${this._url}\",response=\"${ha3}\"`;\n            } else if (type === \"Basic\") {\n              // Basic Authentication\n              // https://xkcd.com/538/\n              const b64 = Buffer.from(\n                `${this.username}:${this.password}`\n              ).toString(\"base64\");\n              authString = `Basic ${b64}`;\n            }\n\n            Object.assign(headers, {\n              Authorization: authString,\n            });\n\n            resolve(this.request(requestName, headers, url)); // Call this.request with Authorized request\n            return;\n          }\n\n          reject(new Error(`Bad RTSP status code ${statusCode}!`));\n          return;\n        }\n      };\n\n      this.on(\"response\", responseHandler);\n    });\n  }\n\n  respond(status: string, headersParam: Headers = {}): void {\n    if (!this._client) {\n      return;\n    }\n\n    // mutable via string addition\n    let res = `RTSP/1.0 ${status}\\r\\n`;\n\n    const headers = {\n      ...this.headers,\n      ...headersParam,\n    };\n\n    res += Object.entries(headers)\n      .map(([key, value]) => `${key}: ${value}\\r\\n`)\n      .join(\"\");\n\n    this.emit(\"log\", res, \"C->S\");\n    this._client.write(`${res}\\r\\n`);\n  }\n\n  async play(): Promise<void> {\n    if (!this.isConnected) {\n      throw new Error(\"Client is not connected.\");\n    }\n\n    await this.request(\"PLAY\", { Session: this._session });\n  }\n\n  async pause(): Promise<void> {\n    if (!this.isConnected) {\n      throw new Error(\"Client is not connected.\");\n    }\n\n    await this.request(\"PAUSE\", { Session: this._session });\n  }\n\n  async sendAudioBackChannel(audioChunk: Buffer): Promise<void> {\n    let rtp, buf;\n    const bufSize = 160;\n    while (audioChunk.length > 0) {\n      if (audioChunk.length > bufSize) {\n        buf = audioChunk.slice(0, bufSize);\n        audioChunk = audioChunk.slice(bufSize, audioChunk.length);\n      } else {\n        buf = audioChunk.slice(0, audioChunk.length);\n        audioChunk = Buffer.from([]);\n      }\n      if (!rtp)\n        rtp = new RTPPacket(buf);\n      else\n        rtp.payload = buf;\n      // rtp.type = 8;// set ng\n      rtp.time += buf.length;\n      rtp.seq++;\n      const bufferLength = Buffer.alloc(2);\n      bufferLength.writeUInt16BE(rtp.packet.length, 0);\n      let channelInterleaved = this.setupResult.filter((value) => {\n        return value.mediaSource.type === 'audio' && value.mediaSource.direction === 'sendonly';\n      })[0].transport.interleaved;\n      /* RTSP Interleaved Frame structure\n      |dollar sign|channel identifier|data length|\n      |1 Byte     |1 Byte            |2 Bytes    |\n      */\n      channelInterleaved = channelInterleaved.split('-')[0];\n      let interleavedHeader = Buffer.from([0x24]);// set '$'\n      interleavedHeader = Buffer.concat([interleavedHeader, Buffer.from([channelInterleaved])]);\n      interleavedHeader = Buffer.concat([interleavedHeader, bufferLength]);\n      const dataToSend = Buffer.concat([interleavedHeader, rtp.packet]);\n      await this._socketWrite(this.tcpSocket, dataToSend);\n    }\n    return;\n  }\n\n  async close(isImmediate = false): Promise<void> {\n    if (this.closed) return;\n    this.closed = true;\n\n    if (!this._client) {\n      return;\n    }\n\n    if (!isImmediate) {\n      await this.request(\"TEARDOWN\", {\n        Session: this._session,\n      });\n    }\n\n    this._client.end();\n    this.removeAllListeners(\"response\");\n\n    if (this._keepAliveID != undefined) {\n      clearInterval(this._keepAliveID);\n      this._keepAliveID = undefined;\n    }\n\n    this.isConnected = false;\n    this._cSeq = 0;\n  }\n\n  _onData(data: Buffer): void {\n    let index = 0;\n\n    // $\n    const PACKET_START = 0x24;\n    // R\n    const RTSP_HEADER_START = 0x52;\n    // /n\n    const ENDL = 10;\n\n    while (index < data.length) {\n      // read RTP or RTCP packet\n      if (\n        this.readState == ReadStates.SEARCHING &&\n        data[index] == PACKET_START\n      ) {\n        this.messageBytes = [data[index]];\n        index++;\n\n        this.readState = ReadStates.READING_RAW_PACKET_SIZE;\n      } else if (this.readState == ReadStates.READING_RAW_PACKET_SIZE) {\n        // accumulate bytes for $, channel and length\n        this.messageBytes.push(data[index]);\n        index++;\n\n        if (this.messageBytes.length == 4) {\n          this.rtspPacketLength =\n            (this.messageBytes[2] << 8) + this.messageBytes[3];\n\n          if (this.rtspPacketLength > 0) {\n            this.rtspPacket = Buffer.alloc(this.rtspPacketLength);\n            this.rtspPacketPointer = 0;\n            this.readState = ReadStates.READING_RAW_PACKET;\n          } else {\n            this.readState = ReadStates.SEARCHING;\n          }\n        }\n      } else if (this.readState == ReadStates.READING_RAW_PACKET) {\n        this.rtspPacket[this.rtspPacketPointer++] = data[index];\n        index++;\n\n        if (this.rtspPacketPointer == this.rtspPacketLength) {\n          const packetChannel = this.messageBytes[1];\n          if ((packetChannel & 0x01) === 0) {\n            // even number\n            const packet = parseRTPPacket(this.rtspPacket);\n\n            // Get the Session Detail\n            const detail = this.setupResult.find(item => item.rtpChannel == packetChannel);\n            if (detail != undefined) packet.wallclockTime = this.GetWallClockTime(packet, detail);\n\n            this.emit(\"data\", packetChannel, packet.payload, packet);\n          }\n          if ((packetChannel & 0x01) === 1) {\n            // odd number\n            const packet = parseRTCPPacket(this.rtspPacket);\n\n            // If this is a Sender Report, cache the NTP Wall Clock data\n            if (packet.packetType == 200 && packet.senderReport != undefined) {\n              const detail = this.setupResult.find(item => item.rtcpChannel == packetChannel);\n              if (detail != undefined) {\n                detail.sr_ntpMSW = packet.senderReport.ntpTimestampMSW;\n                detail.sr_ntpLSW = packet.senderReport.ntpTimestampLSW;\n                detail.sr_rtptimestamp = packet.senderReport.rtpTimestamp;\n              }\n            }\n            \n            this.emit(\"controlData\", packetChannel, packet);\n\n            const receiver_report = this._emptyReceiverReport();\n            this._sendInterleavedData(packetChannel, receiver_report);\n          }\n          this.readState = ReadStates.SEARCHING;\n        }\n        // read response data\n      } else if (\n        this.readState == ReadStates.SEARCHING &&\n        data[index] == RTSP_HEADER_START\n      ) {\n        // found the start of a RTSP rtsp_message\n        this.messageBytes = [data[index]];\n        index++;\n\n        this.readState = ReadStates.READING_RTSP_HEADER;\n      } else if (this.readState == ReadStates.READING_RTSP_HEADER) {\n        // Reading a RTSP message.\n\n        // Add character to the messageBytes\n        // Ignore /r (13) but keep /n (10)\n        if (data[index] != 13) {\n          this.messageBytes.push(data[index]);\n        }\n        index++;\n\n        // if we have two new lines back to back then we have a complete RTSP command,\n        // note we may still need to read the Content Payload (the body) e.g. the SDP\n        if (\n          this.messageBytes.length >= 2 &&\n          this.messageBytes[this.messageBytes.length - 2] == ENDL &&\n          this.messageBytes[this.messageBytes.length - 1] == ENDL\n        ) {\n          // Parse the Header\n\n          const text = String.fromCharCode.apply(null, this.messageBytes);\n          const lines = text.split(\"\\n\");\n\n          this.rtspContentLength = 0;\n          this.rtspStatusLine = lines[0];\n          this.rtspHeaders = {};\n\n          lines.forEach((line) => {\n            const indexOf = line.indexOf(\":\");\n\n            if (indexOf !== line.length - 1) {\n              const key = line.substring(0, indexOf).trim();\n              const data = line.substring(indexOf + 1).trim();\n\n              this.rtspHeaders[key] =\n                key != \"Session\" && data.match(/^[0-9]+$/)\n                  ? parseInt(data, 10)\n                  : data;\n\n              // workaround for buggy Hipcam RealServer/V1.0 camera which returns Content-length and not Content-Length\n              if (key.toLowerCase() == \"content-length\") {\n                this.rtspContentLength = parseInt(data, 10);\n              }\n            }\n          });\n\n          // if no content length, there there's no media headers\n          // emit the message\n          if (!this.rtspContentLength) {\n            this.emit(\"log\", text, \"S->C\");\n\n            this.emit(\"response\", this.rtspStatusLine, this.rtspHeaders, []);\n            this.readState = ReadStates.SEARCHING;\n          } else {\n            this.messageBytes = [];\n            this.readState = ReadStates.READING_RTSP_PAYLOAD;\n          }\n        }\n      } else if (\n        this.readState == ReadStates.READING_RTSP_PAYLOAD &&\n        this.messageBytes.length < this.rtspContentLength\n      ) {\n        // Copy data into the RTSP payload\n        this.messageBytes.push(data[index]);\n        index++;\n\n        if (this.messageBytes.length == this.rtspContentLength) {\n          const text = String.fromCharCode.apply(null, this.messageBytes);\n          const mediaHeaders = text.split(\"\\n\");\n\n          // Emit the RTSP message\n          this.emit(\n            \"log\",\n            String.fromCharCode.apply(null, this.messageBytes) + text,\n            \"S->C\"\n          );\n\n          this.emit(\n            \"response\",\n            this.rtspStatusLine,\n            this.rtspHeaders,\n            mediaHeaders\n          );\n          this.readState = ReadStates.SEARCHING;\n        }\n      } else {\n        // unexpected data\n        throw new Error(\n          \"Bug in RTSP data framing, please file an issue with the author with stacktrace.\"\n        );\n      }\n    } // end while\n  }\n\n  _sendInterleavedData(channel: number, buffer: Buffer): void {\n    if (!this._client) {\n      return;\n    }\n\n    const req = `${buffer.length} bytes of interleaved data on channel ${channel}`;\n    this.emit(\"log\", req, \"C->S\");\n\n    const header = Buffer.alloc(4);\n    header[0] = 0x24; // ascii $\n    header[1] = channel;\n    header[2] = (buffer.length >> 8) & 0xff;\n    header[3] = (buffer.length >> 0) & 0xff;\n\n    const data = Buffer.concat([header, buffer]);\n    this._client.write(data);\n  }\n\n  _sendUDPData(host: string, port: number, buffer: Buffer): void {\n    const udp = dgram.createSocket(\"udp4\");\n    udp.send(buffer, 0, buffer.length, port, host, (_err, _bytes) => {\n      // TODO: Don't ignore errors.\n      udp.close();\n    });\n  }\n\n  _emptyReceiverReport(): Buffer {\n    const report = Buffer.alloc(8);\n    const version = 2;\n    const paddingBit = 0;\n    const reportCount = 0; // an empty report\n    const packetType = 201; // Receiver Report\n    const length = report.length / 4 - 1; // num 32 bit words minus 1\n    report[0] = (version << 6) + (paddingBit << 5) + reportCount;\n    report[1] = packetType;\n    report[2] = (length >> 8) & 0xff;\n    report[3] = (length >> 0) & 0xff;\n    report[4] = (this.clientSSRC >> 24) & 0xff;\n    report[5] = (this.clientSSRC >> 16) & 0xff;\n    report[6] = (this.clientSSRC >> 8) & 0xff;\n    report[7] = (this.clientSSRC >> 0) & 0xff;\n\n    return report;\n  }\n\n  async _socketWrite(socket: SocketUnion, data: Buffer): Promise<void> {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        socket.write(data, (error: Error | null) => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve(undefined);\n          }\n        })\n      }, 20);\n    })\n  }\n\n  ntpBaseDate_ms = new Date(\"1900/1/1\").getTime();\n\n  // Note we have had a RTP Packet in Yellowstone for many years, but the Audio Backchennal code added another object also called RTPPacket\n  GetWallClockTime(packet: util.RTPPacket, detail: Detail): Date | undefined {\n\n  // Add Wall Clock Time\n  if (detail.sr_ntpMSW != undefined && detail.sr_ntpLSW != undefined && detail.sr_rtptimestamp != undefined && detail.mediaSource.rtp[0].rate != undefined) {\n    const refTimestampSecs = detail.sr_rtptimestamp / detail.mediaSource.rtp[0].rate; // H264 is 90 kHz clock rate\n    const packetTimestampSecs = packet.timestamp / detail.mediaSource.rtp[0].rate; // eg 90kHz\n    const packetTimestampDeltaSecs = packetTimestampSecs - refTimestampSecs;\n    const refTimestamp = new Date(this.ntpBaseDate_ms + (detail.sr_ntpMSW * 1000) + ((detail.sr_ntpLSW/Math.pow(2,32))*1000));\n    const wallclockTime = new Date(refTimestamp.getTime() + (packetTimestampDeltaSecs*1000));\n    return wallclockTime;\n  }\n\n  // Could not generate a Wall Clock Time\n    return undefined;\n  }\n\n}\n\nexport { RTPPacket, RTCPPacket } from \"./util\";\n"]}